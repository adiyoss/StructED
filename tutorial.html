<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="StructED, structured prediction learning package">
    <meta name="author" content="adiyoss yossi adi joseph keshet">
    <link rel="icon" href="../../favicon.ico">

    <title>StructED - Tutorial</title>

    <!-- Bootstrap core CSS -->
    <link href="css/bootstrap.css" rel="stylesheet">

   <!-- Custom styles for this template -->
    <link href="css/navbar-fixed-top.css" rel="stylesheet">
    <link href="css/sticky-footer-navbar.css" rel="stylesheet">
    <!-- Custom styles for this template -->
    <link href="css/jumbotron.css" rel="stylesheet">

    <!-- Just for debugging purposes. Don't actually copy these 2 lines! -->
    <!--[if lt IE 9]><script src="../../assets/js/ie8-responsive-file-warning.js"></script><![endif]-->
    <script src="assets/ie-emulation-modes-warning.js"></script>

    <!-- Custom Fonts -->
    <link href="font-awesome/css/font-awesome.min.css" rel="stylesheet" type="text/css">
    <link href="http://fonts.googleapis.com/css?family=Lato:300,400,700,300italic,400italic,700italic" rel="stylesheet" type="text/css">

    <!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"></script>
      <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->
      <!-- USED FOR LATEX CODE INSIDE THE HTML -->
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        extensions: ["tex2jax.js"],
        jax: ["input/TeX","output/HTML-CSS"],
        tex2jax: {inlineMath: [["$","$"],["\\(","\\)"]]}
      });
    </script>
    <script type="text/javascript" src="js/MathJax.js"></script>  
  </head>

  <body>

    <nav class="navbar navbar-inverse navbar-fixed-top">
      <div class="container">
        <div class="navbar-header">
          <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
          <a class="navbar-brand" href="index.html">StrcutED</a>
        </div>
        <div id="navbar" class="navbar-collapse collapse">
          <ul class="nav navbar-nav navbar-right">            
            <li><a href="introduction.html">Introduction</a></li>
            <li><a href="algorithms.html">Algorithms</a></li>
            <li><a href="api/index.html" target="blank">API</a></li>
            <li><a href="examples.html">Examples</a></li>
            <li><a href="contact.html">Contact</a></li>            
            <li><a href="https://github.com/adiyoss/StructED" target="blank"><i class="fa fa-github fa-fw fa-lg"></i></a></li>
          </ul>
        </div><!--/.nav-collapse -->
      </div>
    </nav>

    <div class="container">
      <div>
          <h2 class="text-center">Tutorial</h2>
          <hr>
          <div>            
            <div>
              <p>In order to use StructED to a specific task one should implement three interfaces which contains four functions:</p>
              <ol>
                <li>Loss function from ITaskLoss interface.</li>
                <li>An argmax over the linear discriminant function from IInference interface.</li>
                <li>An argmax over the loss-augmented linear discriminant function from IInference interface.</li>
                <li>A function for computing Phi from IFeatureFunctions interface.</li>
              </ol>

              <div>        
                <div>
                  <h3>Introduction</h3>
                  <hr>
                  
                  In this tutorial we will demonstrate how to use and add new task to the StructED package. We will give code examples for the Task-Loss, Predict - Inference and Feature Functions interfaces. For this tutorial we will use small subset from a dummy data that was generated in our lab in order to debug the vowel duration measurement problem.
                  
                  <br><br>
                  <b>
                    <h4>Before we begin!</h4>
                    You can use this tutorial in two ways:                  
                    <ol>
                      <li>Run the code as we implemented it:</li>
                      In order to run the tutorials you can simply run the bash script in any of the tutorials directories in our <a href="https://github.com/adiyoss/StructED" target="blank">GitHub</a> repository. The tutorials can be found under the tutorials-code directory under dummy folder. <br><br>
                      <li>Write the code yourself:</li>      
                      We should setup our development environment first. Open a Java project and add the StructED jar file to your build path (it can be found under the bin directory at StructED repository). You can download all StructED source codes and jar files from <a href="https://github.com/adiyoss/StructED" target="blank">GitHub.</a>              
                    </ol>                                 
                    Now let's begin!
                    <br>
                  </b>
              </div>
              <div>
                  <h3>Dummy Data</h3>
                  <hr>
                  
                  The dummy data we use in this tutorial was generated in order to debug the vowel duration measurement problem. Hence, the label for each example is composed from two numbers, the start time and end time ($Y\in{\mathbb{R}}^2$), and the input data is an arbitrary length vector of numbers for 0,1 domain, ($X \in{\{0,1\}}^d$ and $d\in{\mathbb{N}}$). <br><br>
                        For example: 

                        8-17 0:0 1:0 2:1 3:0 4:0 5:0 6:0 7:0 8:1 9:1 10:1 11:0 12:1 13:1 14:1 15:1 16:1 17:0 18:0 19:0<br><br>

                  Here, the first two numbers are the label which indicates that the signal turns on at the eighth element of the vector and turns off at the seventeenth element of the vector. Each vector data is composed from the index of the feature, we did this to support space features, and the feature data separated by a colon(:). <br><br>

                  Our goal is to find a function $ f$ that gets as input the vector data and outputs the start time where the signal turns on and end time where it turns off. Notice, we add a little bit off noise to the vector data for example at the second index or at the eleventh index, we want to fine $ f$ that isn't sensitive to small amount of noise in the data. We know that this is a toy example, but it demonstrate really good the use of the package and the integration with it. We assume that the signal turns on only once.
                  <br><br>
                  The DB can be found under the db/ folder in this tutorial zip file.
                  
              </div>
              <div>
                  <h3>The Code</h3>
                  <hr>
                  <div>
                    Here, we present what classes do we need to add and what interfaces do we need to implement. We provide the source code for all of the classes and interfaces. <br><br>

                    <h4>Task Loss</h4>
                    First we define out measure of performance. Every task has defines its own function. In out package, in order to create new loss function one should implement the ITaskLoss interface. In our problem settings we use the following loss function: 
                    <p class="text-center">              
                      \begin{equation}
                      \label{eq:loss}
                        \ell ((t_{s}, t_{e}),(\hat{t_{s}}, \hat{t_{e}})) = max{\{|(\hat{t_{s}}-\hat{t_{e}}) - (t_{s} - t_{e})| - \epsilon ,0\}}
                      \end{equation}   
                    </p>
                    In words, the loss will be the max between zero to the difference between the predicted signals length to its actual length and we minus epsilon. This means that we allow the classifier to be mistaken by at most epsilon.
                    <br><br>
                    For this we create new Java class inside that implements the ITaskLoss interface. The code for the implementation of this class is attached to this tutorial.<br><br>

                    <h4>Inference</h4>
                    Now we turn to define our inference functions. Every inference class should implement the IInference interface. <br>
                    In our problem settings the inference will be a brute force. We assume that at the beginning and at the end there is a gap of three frames, which means the beginning of the of the signal can not be in the first 3 frames and the end of the signal can not be at the last three frames, this can be redefined otherwise if needed. <br>
                    Out inference will go over all the possible time pairs for the start and end times, starting from minimum gap to maximum gap. 
                    <br><br>

                    In general we need the Inference class to implement the following:

                    <p class="text-center">
                      \begin{equation}
                      \label{eq:decoding}
                      \hat{y}_{w}(x) = argmax_{\mathcal{y} \in \mathcal{Y}} ~ w^\top \phi(x, y)
                      \end{equation}
                    </p>

                            and,

                    <p class="text-center">
                      \begin{equation}
                      \label{eq:augmented-loss}
                      \hat{y}_{w}(x) = argmax_{\mathcal{y} \in \mathcal{Y}} ~ w^\top \phi(x, y) + \ell (y,\hat{y})
                      \end{equation}
                    </p>   

                    For this we create new Java class inside the com.structed.models.inference package, this class should implement the IInference interface. The code for the implementation of this class is attached to this tutorial or can be found at the tutorial folder.
                    <br><br>                    

                    <h4>Feature Functions</h4>
                    We now add the feature functions. Every feature function class should implement the IFeatureFunctions interface. Since we want to recognize the pick of the start of the signal and the decrease of the end signal we implemented the following feature functions:
                    <br><br>
                    <ol>
                      <li>Difference between the element at the start index to the element at index start - 1</li>
                      <li>Difference between the element at the start index to the element at index start - 2</li>
                      <li>Difference between the element at the end index to the element at index end + 1</li>
                      <li>Difference between the element at the end index to the element at index end + 2</li>
                      <li>Difference between the mean of the signal from start to end to the mean of the signal from start to start - 3</li>
                      <li>Difference between the mean of the signal from start to end to the mean of the signal from end to end + 3</li>
                    </ol>
                    We expect that the value of the above feature functions will be high when we reach the true start time and end time, and low otherwise.
                    <br><br>
                    For this we create new Java class inside the com.structed.data.featureFunctions package, this class should implement the IFeatureFunctions interface. The code for the implementation of this class is attached to this tutorial or can be found at the tutorial folder.
                    <h4>Storing the train/test examples</h4>
                    <div>
                      StructED uses an InstanceContainer class to store its examples, the instance container contains the data/labels and paths for all the examples. Each example is stored in a data structure called Example1D. We implemented a standard reader for this cases, when using StructED to different tasks one can either use one of our standard readers or to implement a new one.
                    </div>
                  </div>                
              </div>
              <div>
                  <h3>Running The Code</h3>
                  <hr>
                  Now we can create a StructEDModel object with the interfaces we have just implemented, all we have left to do is to choose the model. Here is a snippet of such code (the complete code can be found at the package repository under tutorials-code folder):
                  <br><br>                 
                  <div>
                    <pre class="prettyprint">
                
        Logger.info("Dummy data example.");
        int readerType = 0;
        int epochNum = 3;
        int isAvg = 1;
        int numExamples2Display = 3;
        // &ltthe path to the train dummy data&gt
        String trainPath = "data/train.txt"; 
        // &ltthe path to the test dummy data&gt
        String testPath = "data/test.txt"; 

        // load the data
        Reader reader = getReader(readerType);
        InstancesContainer dummyTrainInstances = reader.readData(trainPath, Consts.SPACE, 
              Consts.COLON_SPLITTER);
        InstancesContainer dummyTestInstances = reader.readData(testPath, 
              Consts.SPACE, Consts.COLON_SPLITTER);
        if ( dummyTrainInstances.getSize() == 0 ) return;

        // ======= PASSIVE AGGRESSIVE ====== //
        // init the first weight vector
        Vector W = new Vector() {{put(0, 0.0);}}; 
        // model parameters
        ArrayList&ltDouble&gt arguments = new ArrayList&ltDouble&gt(){{add(3.0);}}; 
        // task loss parameters
        ArrayList&ltDouble&gt task_loss_params = new ArrayList&ltDouble&gt(){{add(1.0);}}; 

        // create the model
        StructEDModel dummy_model = new StructEDModel(W, new PassiveAggressive(), new TaskLossDummyData(),
                new InferenceDummyData(), null, new FeatureFunctionsDummy(), arguments); 
        // train
        dummy_model.train(dummyTrainInstances, task_loss_params, null, epochNum, isAvg); 
        // predict
        ArrayList&ltPredictedLabels&gt labels = dummy_model.predict(dummyTestInstances, task_loss_params, 
                numExamples2Display); 

        // print the prediction
        for(int i=0 ; i&ltdummyTestInstances.getSize() ; i++)
            Logger.info("Y = "+dummyTestInstances.getInstance(i).getLabel()+", Y_HAT = "+
                labels.get(i).firstKey());
        Logger.info("");       

                    </pre>
                  </div>  
                  <br><br>
                  You can see that changing the model is pretty straightforward:
                  <br><br>
                <div>
                    <pre class="prettyprint">
                
        // ======= CRF ====== //
        // init the first weight vector
        W = new Vector() {{put(0, 0.0);}}; 
        // model parameters
        arguments = new ArrayList&ltDouble&gt(){{add(0.1);add(0.1);}}; 

        // create the model
        StructEDModel dummy_model_crf = new StructEDModel(W, new CRF(), new TaskLossDummyData(),
                new InferenceDummyData(), null, new FeatureFunctionsDummy(), arguments); 
        // train
        dummy_model_crf.train(dummyTrainInstances, task_loss_params, null, epochNum, isAvg); 
        // predict
        labels = dummy_model_crf.predict(dummyTestInstances, task_loss_params, numExamples2Display); 

        // print the prediction
        for(int i=0 ; i&ltdummyTestInstances.getSize() ; i++)
            Logger.info("Y = "+dummyTestInstances.getInstance(i).getLabel()+", Y_HAT = "+
                  labels.get(i).firstKey());
        Logger.info("");       

                    </pre>
                  </div>                 
              </div>
            </div>
          </div>
        </div>
      </div>
    </div> <!-- /container -->  
    <footer class="footer">
      <div class="container">
      </div>
    </footer>

    <!-- Bootstrap core JavaScript
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
    <script src="js/bootstrap.min.js"></script>
    <!-- IE10 viewport hack for Surface/desktop Windows 8 bug -->
    <script src="assets/ie10-viewport-bug-workaround.js"></script>
    <script src="https://cdn.rawgit.com/google/code-prettify/master/loader/run_prettify.js"></script>
  </body>
</html>
